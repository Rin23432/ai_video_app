AI漫剧生成器与二次元创作社区 Android App – 产品需求文档(PRD)及技术架构方案
一、产品概述和定位

本产品是一个融合AI 漫剧自动生成与二次元创作社区功能的移动应用，目标是在移动端为用户提供一站式的二次元内容创作和分享平台。用户可以通过简单的文字输入(prompt)，利用云端大模型生成漫画剧本、分镜画面和角色立绘，并合成短视频形式的漫剧作品(典型时长1～5分钟)。生成的作品可发布到社区，与其他二次元爱好者互动交流。应用风格将突出年轻化的二次元主题，参考网易 LOFTER 等创作社区的兴趣圈层特点和橙光互动阅读平台的创作工具模式，打造一个面向Z世代用户的创意分享空间。

本产品主要定位如下：

目标用户：热爱动漫、轻小说、漫画创作的年轻群体（以90后、00后为主），包括有创作欲望但缺乏绘画/动画专业技能的普通用户，以及二次元内容创作者等。LOFTER 上以摄影、插画、文学创作为主的Z世代用户，以及橙光平台上千万计的互动阅读作者群体，证明了此类用户对易用创作工具和社区分享的强需求。

核心价值：降低动漫/漫剧内容创作门槛，让不会画画、不懂制作的人也能把脑中的故事“拍”成漫剧，实现“用户即作者”的理念。AI技术赋能创作全流程，提高效率并减少成本，使单部作品的制作周期缩短至数小时/数天（传统动画可能需数月）。同时，通过社区运营，帮助创作者展示作品、获得反馈、找到同好，增强创作动力。

差异化：结合了LOFTER的兴趣标签体系和社交互动（如点赞、评论、转发）以及橙光的剧情创作工具属性。与传统漫画/动画制作平台相比，本产品突出AI一键生成的便捷；与纯AI绘画工具不同的是，配套了社区生态和内容管理。用户可在这里即创作又分享，形成闭环。参考业界实践，阅文、知乎等公司已推出“漫剧助手”等AI创作平台以提升改编效率，字节跳动等的AI视频生成模型将文本直接生成多镜头视频，被称为“导演级AI”。我们的产品将站在这一技术趋势上，提供面向大众用户的漫剧生成器。

当前不考虑商业化盈利，不引入付费和广告机制，专注于打磨产品功能和社区互动体验，优先获取用户认可和内容沉淀。随着用户规模和内容质量提升，再适时考虑后续商业模式。

二、功能需求详述 (PRD)

本节按照功能模块，详细说明应用应实现的主要功能需求和用户体验。功能设计充分借鉴成熟产品（如LOFTER、橙光）的架构，同时结合AI内容生成的特点。

1. 用户系统

1.1 用户注册/登录：提供多种登录方式，包括手机号+验证码注册登录、用户名/密码登录，以及第三方平台一键登录（如微信、微博等）以降低注册门槛。支持游客模式浏览：未登录用户可在应用内浏览公共内容，但尝试点赞、评论、创作时需提示登录。登录后为用户创建个人账号，保存其头像、昵称、简介等基本资料。

1.2 用户个人主页：每个注册用户有自己的主页，展示Ta的头像、昵称、签名、自定义背景等。主页上分区展示用户的创作作品、获得的点赞数、粉丝数、关注列表等。支持个人主页定制，例如选择二次元风格的背景图或主题色。用户可编辑个人资料，修改头像昵称等。其他用户访问时，可以关注该作者或浏览TA的作品合集。

1.3 关注/社交关系 (扩展)：初期版本可不强制要求关注功能，但预留用户关注/粉丝关系，用于后续个性化内容推荐。用户可以关注喜欢的创作者，关注后其作品动态会在“发现”或专门的关注动态页出现。用户间可发送私信(可考虑后续版本加入)以便深入交流。

2. AI漫剧生成器

这是应用的核心功能模块，让用户通过AI自动生成漫剧内容：

2.1 Prompt输入与剧本生成：用户在生成器界面输入文字描述(prompt)，描述他们想要的剧情、大纲或场景。例如：“两个魔法少女在樱花树下相遇，一起对抗黑暗势力，最终成为朋友”。用户可选择剧本的风格/主题标签（如校园、奇幻、搞笑等）以供AI参考。点击“生成剧本”后，后台调用大型语言模型（LLM）根据prompt编写一个剧情脚本，包括对话、场景分段等。此脚本相当于漫剧的文字剧本，为后续画面生成提供基础。根据业界报道，AI已经能够深度参与剧本创作，显著提升脚本撰写效率。

2.2 场景分镜与画面生成：根据生成的剧本，系统自动进行分镜处理：将剧本拆分为若干场景片段或对话节点。然后利用图像生成模型（如Stable Diffusion或类似的动漫风格扩散模型），为每个场景生成对应的立绘/画面。包括角色形象、背景环境等元素。为了保持角色的一致性和画风统一，系统会提取主角角色描述，使用同一角色设定生成多张图像，避免每一帧角色差异过大。如果仍出现角色形象不一致的问题，提供重新生成某一画面的选项（用户可以手动指定某张图重画）。生成时也可以让用户选择画风（例如日漫、国漫、Q版等）以约束模型风格。

2.3 漫剧合成与预览：在获得一系列分镜画面后，系统将这些画面按照剧本顺序合成一段连续的漫剧视频。合成过程中，可为每个画面添加字幕（剧本对白）、过渡动画（例如淡入淡出、视差滚动效果）和背景音乐/音效。如果条件允许，还可以调用AI配音服务为角色对白添加语音，让漫剧更具沉浸感（语音功能可列为后续优化）。合成完毕后，用户可以在应用内预览这段短视频效果。预览播放器提供播放、暂停、进度拖动功能，用户确认满意后即可发布；如果不满意，可修改prompt重新生成或对剧本进行微调再生成。

2.4 生成参数和历史：高级用户可以调整一些生成参数，如每次生成的镜头数量或画面分辨率、角色设定等。系统也会保存用户最近若干次生成的历史记录（包括prompt、生成的剧本文本以及图像缩略图），方便用户对比选择最佳结果，或在之后继续编辑之前生成的作品。历史生成记录仅本人可见，未发布的作品保存在“草稿”状态。

2.5 操作反馈：由于AI生成需要一定时间（可能数十秒到几分钟视复杂度而定），应用需要提供任务进度反馈。在用户提交prompt后，UI上应显示“生成中”状态提示和进度动画。对于耗时较长的任务，可以采用异步任务模式：生成任务提交后返回任务ID，用户可稍后查看进度或收到完成通知。任务完成时，可本地推送通知或在App内提醒用户结果已就绪。这样的任务调度方式也利于后端缓冲请求，高效利用AI算力资源。

参考：网易LOFTER曾上线“老福鸽画画机”功能，让用户输入关键词自动生成插画。本模块与其思路类似，但生成的是连贯剧情的多张图像及视频。当前行业中如阅文的“漫剧助手”或 KomikoAI 等工具也提供从角色设计、剧本到分镜的一站式AI漫画创作流程。本产品将集成这些能力于移动端。

3. 内容发布与互动系统

创作完成后，用户可一键发布作品到社区，与其他用户互动。主要功能包括：

3.1 作品发布：支持将AI生成的漫剧作品发布到平台。发布时，用户需要填写作品的标题（必填）、简介（选填，对作品的介绍或创作感想）和标签（选填，从系统预置的分类标签中选择，如“奇幻”“校园”“搞笑”等，也可自定义标签）。发布时可以选择同步发布图片版（如四格漫画图片）或视频版（漫剧动画），亦可两者都发布。文件会上传至服务器的对象存储，生成对应的播放链接。作品默认为公开发布，后续可考虑私人/粉丝可见的权限设置。

3.2 内容展示：发布后的作品将在社区中展示。对于视频类漫剧，在移动端采用视频流播放器播放，用户可以全屏观看或横屏模式。对于图片形式的（如分镜图片或条漫），提供图片浏览组件（支持横滑分页或下拉长图模式）。作品页面除了展示标题、作者、发布日期、正文（视频或图片）外，还包括互动信息：点赞数、评论数、分享按钮等。页面底部提供评论列表和输入框。

3.3 点赞/收藏/分享：登录用户可以对喜欢的作品点“点赞”，提升作品热度。【交互】：再次点击可取消点赞。作品可被加入用户的收藏夹（暂定收藏功能可与点赞合并，不单独实现也可）。分享功能支持将作品链接或海报图分享至站外，如微信好友/朋友圈、微博、QQ等，通过系统分享接口实现，引导更多流量回流。作品被点赞、评论时，作者应收到通知（App内消息推送），提高互动反馈。

3.4 评论互动：用户可在作品下发表评论，表达观感或与作者交流。评论支持纯文本（未来可考虑emoji表情）。评论列表按时间或热度排序展示。针对评论，可以实现二级回复（回复楼中楼）以便讨论。作者或版主可以删除不当评论。评论系统需要与后台审核配合，对含违规内容的评论进行过滤或屏蔽，确保社区氛围友好。参考LOFTER等社区产品，频繁的点赞、评论互动营造了以兴趣为核心的活跃社区。

3.5 内容审核机制：由于平台内容由用户发布且含AI生成成分，必须有健全的审核。主要包括：

发布前自动审核：在用户提交发布请求后，后端调用内容安全服务对文本和图像进行审核（如检查政治敏感词、涉黄涉暴元素等）。可利用第三方AI内容审核API或自研模型筛查。未通过审核的作品不给予发布，并提示用户修改。

人工审核：对通过机器审核的新内容，标记为“待审核”状态，由后台管理员进行二次人工检查。一旦发现违规内容，管理员可直接下架或删除。对于通过审核的内容，将其状态设为“公开”使其在前台可见。审核机制确保社区健康、安全的内容环境。

用户举报：提供举报按钮，用户可举报不当内容或侵权作品。后台收到举报及时处理，严重违规者可封禁账号。

4. 发现 (内容探索) 模块

为了提高内容消费和社区活跃度，App 提供发现页聚合浏览最新和热门内容，帮助用户发现感兴趣的作品和创作者：

4.1 推荐内容流：进入发现页，默认展示平台热门推荐内容流。推荐算法初期以简单规则为主（如按照作品发布时间、新用户必看的精选作品、全站点赞数排序的热门作品等）。后期可引入个性化推荐，根据用户兴趣标签、观看历史来智能排列顺序。LOFTER 通过丰富的标签和互动形成了独特的兴趣推荐氛围，我们也将利用标签和用户行为改进推荐质量。

4.2 分类/标签浏览：提供分类筛选功能，按题材、类型浏览作品。比如设立“奇幻”“恋爱”“校园”“冒险”“同人”等标签频道。用户点击某标签，进入该分类的作品列表页，按最新或最热排序，方便垂直兴趣用户深耕。标签体系有助于内容有效分类，帮助用户更容易地发现同好创作。标签既可由系统预设也可积累用户自定义热门标签。

4.3 搜索功能：在发现页显著位置提供搜索框，支持按作品标题、作者昵称、标签关键字等搜索内容。搜索结果页分为作品和用户两类结果，让用户能直接找到目标。实现技术上可使用后端数据库全文检索，或接入像 Elasticsearch 这样的搜索引擎以提高性能和模糊搜索体验。用户常见的搜索如“某IP同人漫剧”“某作者作品”等都应支持。

4.4 榜单/活动：为了增强社区激励，可以在发现页加入排行榜（如一周人气榜、新人创作者榜）等栏目，鼓励优质内容脱颖而出。也可以不定期举办线上活动（比如主题创作挑战、优秀剧情征集等），并在发现页展示活动入口和优秀作品，刺激用户参与创作和互动。

5. 我的作品 (创作管理)

每个用户都有“我的作品”管理页，汇总其创作的内容和提供管理操作：

5.1 已发布作品列表：列出用户已经发布的所有作品缩略图及标题、发布时间、点赞评论数统计。作者可以点击某个作品查看详情或与他人看到的页面相同。提供编辑/删除功能：作者可以对自己发布的作品修改标题、简介或标签（作品内容本身不可修改，若需修改需重新生成再发布）。删除作品需二次确认，删除后内容对他人不可见，但可考虑在数据库保留记录以便申诉恢复。

5.2 草稿箱：存放未发布的创作。用户在生成器里生成了作品但尚未发布时，可以选择“保存草稿”。草稿包括剧本文本、生成的图像或视频。用户下次可以从草稿箱打开继续编辑（例如重新生成某部分）。草稿仅自己可见，没有互动数据。

5.3 喜欢/收藏：我的作品页也可显示用户点赞过或收藏的他人作品列表（视作用户的内容收藏夹），方便用户回顾欣赏。同时这也反映用户兴趣，用于日后个性化推荐。

5.4 账户设置：在此模块中一般也包括个人账户设置入口，如修改密码、绑定/解绑第三方账户、隐私设置（例如是否允许陌生人私信等），以及退出登录功能。这些属于用户系统的附属功能，保证账号管理的完整性。

6. 后台管理系统

除了前端App，需配套后台管理系统供运营人员和管理员使用，保障内容和社区的平稳运行：

6.1 内容审核后台：列出所有用户发布的作品及其状态（待审核、已发布、已删除等）。管理员可以预览作品内容，查看用户信息和模型生成的剧本文字等，对不合规内容执行下架或删除操作。一旦操作，将更新作品状态并通知用户（可通过站内信告知删除原因）。同时后台应集成敏感内容检测工具，对文本和图像自动标注风险等级，供审核人员参考。审核后台还包括评论审核模块，列表展示被模型或用户举报的评论，支持批量删除。

6.2 用户管理：后台可查询用户列表，查看用户的注册信息、作品数、最后活跃时间等指标。对于严重违规用户（发布大量违规内容、刷榜等），管理员可对其执行封禁、禁言等操作。用户申诉也由管理员在此处理。

6.3 数据统计与内容运营：提供数据面板，统计每日新增用户数、作品发布数、互动量，以及热门标签排行等，用于运营决策。运营人员可在后台设置推荐的内容或标签、编辑社区公告、上线专题活动页面等。比如策划一个“春节二次元创作大赛”，可通过后台配置在App发现页挂出活动入口和规则说明。

6.4 任务调度监控：针对AI生成任务，后台需有任务调度系统的监控界面。显示当前排队的生成任务数、每个任务的状态（进行中、已完成、失败）等。如果某任务长时间未完成，可人工介入重试或取消。管理员也可通过此界面管理AI算力资源的分配，比如高峰期临时扩容生成服务。任务调度系统确保大量并发生成请求下系统依然稳定，提供良好体验。

以上功能模块确保了整个产品从用户创作->发布分享->互动反馈->后台管理的完整闭环，满足初期产品定位需求。接下来详细阐述技术架构设计。

三、技术架构设计

本章节提供系统的整体技术架构方案，包括客户端架构、后端架构、AI推理模块、存储方案等。设计遵循约定的技术栈：Android 前端采用 Kotlin + Jetpack Compose，后端采用Java SSM框架 (Spring + Spring MVC + MyBatis)，数据库使用 MySQL，缓存使用 Redis，对象存储使用 MinIO，AI生成依托云端大模型服务。

系统整体架构示意图：包括Android客户端、后端服务、AI推理服务、数据库、缓存和对象存储等模块的交互关系。客户端通过REST API与后端通信，后端调用AI服务生成内容，并使用数据库、缓存、存储来管理数据。后台管理和内容审核同样通过后端服务接口进行。

3.1 客户端 (Android/Kotlin) 架构

Jetpack Compose 前端架构：Android App 使用 Kotlin 语言开发，UI框架采用 Jetpack Compose 实现响应式界面。Kotlin 作为Android官方首选语言，具备空安全、协程等特性，解决了Java在移动开发中的诸多痛点。Compose 引入声明式UI范式，通过可组合的组件提高开发效率和UI更新性能。两者结合显著提升了开发体验，也为我们构建现代化架构奠定基础。

MVVM模式：客户端内部采用 MVVM 架构模式组织代码，即 Model-View-ViewModel。各界面(View)通过 ViewModel 获取数据(Model)并更新UI，ViewModel负责业务逻辑和状态管理，Model层通过Repository与远程后端或本地数据库交互。这样实现前端与业务逻辑解耦，提高代码可维护性。Compose 的状态管理机制能够方便地与ViewModel的LiveData/Flow结合，实现界面状态的自动刷新。

网络通信：客户端使用 Retrofit 等网络库与后端 RESTful API 通信。数据格式采用 JSON。为了更好的用户体验，网络层实现请求拦截和错误处理，比如统一处理超时重试、弹出错误提示等。对于生成任务等需要长时间等待的操作，可配合Coroutine挂起异步或使用WorkManager计划后台任务，使UI不阻塞并在任务完成后通知用户。

多媒体处理：由于涉及图像、视频的生成和播放，客户端需考虑多媒体处理：使用ExoPlayer实现视频播放，支持流式播放MinIO上的视频文件。对于图片类内容，使用Glide或Coil加载，并缓存常用的图片资源（如封面图）以节省流量。发布时如需上传用户自己的素材（比如头像、封面），在客户端先压缩处理，再通过后端提供的上传接口存储到MinIO。

UI风格：界面设计遵循二次元年轻化风格，使用明亮的配色和卡通元素。Compose提供的Material 3主题可以自定义以匹配二次元风格，例如圆角卡片、动漫角色插图背景等。整体交互注重动效和流畅度：切换页面时可能采用转场动画，点赞时有爱心爆裂动画等，增强趣味性。还可加入轻游戏化元素，比如发布作品后弹出“✨发布成功”动画奖励。所有UI交互在保证趣味的同时，需要确保性能顺滑，对于列表滚动、视频播放等核心场景着重优化。

3.2 后端服务架构

后端采用Java SSM框架，即 Spring + Spring MVC + MyBatis，遵循分层架构设计，提供稳健的 REST API 服务。SSM 是经典的Java企业级开发组合，基于标准MVC模式将应用分为DAO、Service、Controller、View等层。我们将在此架构下实现各模块功能：

Controller 层：基于 Spring MVC，实现各功能模块的 RESTful API 接口。如 UserController 处理用户注册登录请求，ContentController 处理作品发布和获取请求，AIController 处理生成任务请求等。Controller层负责接收请求、参数校验、调用业务逻辑，然后将结果封装为JSON响应返回。每个接口会遵循REST风格设计合理的URL和HTTP方法（详见后续接口设计示例）。

Service 层：封装具体业务逻辑。将复杂的业务操作（比如发布作品需要先保存作品记录、再上传文件、再更新缓存等）在Service层实现，提供事务管理和与DAO层交互。Service层方法供Controller调用，并保证一个请求的完整事务。例如 ContentService.publishContent() 完成作品发布的一系列步骤，UserService.authenticate() 完成用户验证逻辑等。采用 Spring 的IoC容器管理Service Bean，方便解耦和测试。

DAO 层 (Mapper)：采用 MyBatis 实现数据持久化，映射数据库表的CRUD操作。通过XML或注解定义SQL映射，将 Java 对象与表记录转换。DAO接口由MyBatis框架实现，实现细节对Service透明。DAO层专注于数据存取，与数据库交互，例如 UserMapper.insertUser(), ContentMapper.selectContentById() 等方法。数据源配置和连接池在 Spring 配置中统一管理。

实体模型 (Model)：定义与数据库表结构对应的POJO类，如 User、Content、Comment 等，用于DAO与Service之间传递数据。同时根据业务需要定义一些DTO（数据传输对象）用于Controller和前端交互，例如 ContentDTO 包含作品信息及作者昵称、点赞统计等。

其他组件：利用 Spring AOP 实现一些切面功能，例如日志记录、性能监控、权限校验。比如对敏感管理接口加上权限切面，非管理员请求直接拒绝。还可通过AOP实现服务方法的缓存注解，将常用查询结果存入 Redis 以提高响应速度。

SSM架构优势在于清晰的分层和广泛的实践支持：Spring 管理业务对象生命周期、Spring MVC 转发请求和视图管理、MyBatis 高效处理SQL映射。这套框架成熟稳定，利于团队协作和日后维护。

3.3 接口设计与API网关

后端通过RESTful风格的HTTP接口向移动端提供服务。主要特征：资源路径语义清晰，采用不同HTTP方法表示不同操作，返回标准状态码和JSON数据。

URL命名：以资源名复数形式组织，如/api/users表示用户资源，/api/contents表示作品资源。常用接口示例：

POST /api/users/register ：用户注册，提交手机号验证码或用户名密码，返回注册结果。

POST /api/users/login ：用户登录，返回认证Token（如JWT）或会话信息。

GET /api/users/{uid} ：获取用户个人信息和作品统计。

GET /api/contents?tag=奇幻&sort=hot ：查询作品列表，支持按标签过滤和排序。

GET /api/contents/{cid} ：获取单个作品详情（标题、媒体URL、作者、评论等）。

POST /api/contents ：发布新作品，提交作品元数据和媒体内容引用（详细说明见后）。

POST /api/contents/{cid}/comments ：发表评论。

POST /api/contents/{cid}/like ：点赞作品（再次调用取消点赞）。

GET /api/tags ：获取所有标签分类。

GET /api/search?keyword=xxx ：全局搜索，返回匹配的作品和用户列表。

POST /api/generate ：提交AI生成请求（带prompt等参数），返回任务ID。

GET /api/generate/{taskId} ：查询生成任务状态和结果（当完成时可返回作品草稿数据或媒体URL）。

GET /api/admin/contents?status=pending ：【管理员】获取待审核作品列表。

PUT /api/admin/contents/{cid} ：【管理员】修改作品状态（通过/下架）。

... 以及其他管理接口 (如用户封禁 PUT /api/admin/users/{uid}/ban 等)。

请求/响应格式：采用统一的JSON结构。例如：

// 成功响应示例
{
"code": 0,
"msg": "OK",
"data": { ... }
}
// 错误响应示例
{
"code": 1001,
"msg": "Invalid credentials",
"data": null
}

其中code为业务状态码（0为成功，非0为各种错误），msg为描述，data为具体返回数据对象或列表。

安全与认证：用户登录后，后端签发JWT(Token)给客户端，后续请求在Authorization Header附带 token。后端通过拦截器或过滤器校验Token有效性，获取用户身份。未登录用户调用受限接口会返回401需登录。敏感操作（删除作品等）需验证权限或CSRF防护。管理员接口可能采用角色鉴别，同一JWT中携带role信息或使用不同的认证机制。

API网关 (可选)：对于前后端完全分离架构，可在服务端设置API网关统一转发请求到内部微服务。但当前架构后端为统一应用，故无需专门网关。但可以使用Nginx做反向代理，实现URI路由、负载均衡等，如果后期拆分服务，可以平滑过渡。

实时通信 (可选)：如果需要实时向客户端推送消息（如生成任务完成通知，评论消息等），可引入WebSocket机制或基于MQTT的推送服务。初期也可利用长轮询轮询/api/notifications来获取新消息。根据实际需要进行取舍。

3.4 数据库设计 (MySQL)

采用 MySQL 8.x 作为主要数据存储，存储结构化的业务数据。MySQL 是全球流行的开源关系数据库，其可靠性、性能和可扩展性备受认可。下面设计主要的数据库表结构：

用户表 (users) – 存储用户账号信息

id (INT) 主键，自增ID

username (VARCHAR) 用户名/账号（可选，或使用手机号/email作为账号）

password_hash (VARCHAR) 密码哈希（采用安全算法存储，例如BCrypt）

phone (VARCHAR) 手机号（可选，用于验证登录）

email (VARCHAR) 邮箱（可选）

nickname (VARCHAR) 昵称（显示用，可重复）

avatar_url (VARCHAR) 头像URL（指向存储的头像文件）

bio (VARCHAR) 个性签名简介

role (TINYINT) 用户角色标识（0=普通用户, 1=管理员等）

created_at (DATETIME) 注册时间

status (TINYINT) 状态（1=正常, 0=封禁）

说明: 用户表保存基础资料。敏感信息如密码必须加密保存。索引：在username/phone上建立唯一索引，加快登录验证查询。

作品表 (contents) – 存储发布的漫剧作品信息

id (INT) 主键，自增内容ID

user_id (INT) 作者用户ID (外键 references users.id)

title (VARCHAR) 标题

description (TEXT) 简介/创作说明

media_type (TINYINT) 媒体类型（1=视频漫剧, 2=图文漫画等）

media_url (VARCHAR) 媒体文件存储路径或URL（指向MinIO对象存储，如视频文件地址或首张图像地址）

cover_image (VARCHAR) 封面图URL（可以选第一帧图像或用户自选）

duration (INT) 时长（秒），仅视频有值

width/height (INT) 尺寸，图像类内容可用

likes_count (INT) 点赞数（冗余存储以便查询排序，也可不冗余而通过关联count）

comments_count (INT) 评论数

tags (VARCHAR) 标签字符串（例如存“奇幻,校园”作为冗余，或采用关联表存 tags，见后）

created_at (DATETIME) 发布时间

status (TINYINT) 状态（0=待审核,1=公开,2=隐藏下架,3=删除）

说明: 作品表是核心，保存每个发布作品元数据和引用。media_url 指向对象存储中的实际文件。若作品由多张图组成，也可只存首图URL并通过其他表获取全部图列表（例如建立 content_images 表存每个作品的多图）。tags既可冗余存文本，也可以有标签表和内容-标签关联表：

标签表 (tags) – 预置或用户创建的标签

id (INT) 主键

name (VARCHAR) 标签名称

内容标签关联表 (content_tags) – 多对多关系

content_id (INT)

tag_id (INT)
(Primary Key 可设为(content_id, tag_id)联合)

这样可以对作品实现多标签分类，方便用SQL筛选特定标签内容。

评论表 (comments) – 用户对作品的评论记录

id (INT) 主键

content_id (INT) 所属作品ID

user_id (INT) 评论者用户ID

reply_to (INT) 可选，表示回复的评论ID，实现二级评论

text (TEXT) 评论内容

created_at (DATETIME) 评论时间

status (TINYINT) 状态（1=正常,0=删除或屏蔽）

说明: 评论表数据量可能较大，要对 content_id 建索引，以便按作品查询评论列表。同样 user_id 可建索引用于管理查找用户发过的评论。

点赞表 (likes) – 记录用户点赞关系

user_id (INT) 点赞用户

content_id (INT) 被点赞作品

created_at (DATETIME) 点赞时间

说明: 主键可为(user_id, content_id)联合，避免重复点赞。也可不设单独表，而将点赞作为Redis计数 + 用户最近点赞缓存。但为了安全起见，还是落库便于防刷和持久统计。查询某用户点赞过的内容用于“收藏”功能也简单实现。

生成任务表 (generate_tasks) – AI生成任务队列记录

id (BIGINT) 主键，任务ID（可采用雪花算法生成全局唯一ID）

user_id (INT) 发起用户

prompt (TEXT) 用户输入的Prompt文本

result_content_id (INT) 生成完成后对应的内容ID（如果直接保存为草稿内容）

status (TINYINT) 状态（0=排队中,1=进行中,2=成功,3=失败）

progress (INT) 进度百分比（可选）

created_at (DATETIME) 提交时间

finished_at (DATETIME) 完成时间

说明: 任务表用于跟踪AI生成流程。可以在任务完成后，将结果保存为一条未发布的内容(草稿)，并把ID填写到result_content_id。这方便客户端查询任务完成后直接获取内容数据。如果任务失败，也可以存错误原因供分析（可扩展字段error_msg）。

审核表/日志 (audit_logs) – 记录后台审核操作 （可选）

id 主键

content_id (INT)

admin_id (INT) 操作管理员用户

action (VARCHAR) 动作（如 “approve” “reject”）

reason (VARCHAR) 拒绝原因等说明

created_at 时间

说明: 审核日志用来追溯内容的审核处理，便于运营管理。

其他表：如关注关系表 (follows)：保存user_id关注了target_user_id，以及通知表 (notifications) 用于站内消息推送记录等，可根据需求添加。

数据库范式与性能：上述设计基本满足3NF，减少数据冗余。但在某些高频场景下适当反范式化可以提高性能。例如作品的likes_count、comments_count做冗余存储，避免每次计算；内容表中tags文本虽有重复但便于模糊查询。可以接受适度冗余，但需通过触发器或程序维护一致性。建立必要索引如主键索引、外键索引，以及经常查询条件上的索引（如 content.status, content.user_id 等）。考虑未来数据量大时，可进行库表分片或读写分离优化，但初期单库足以支撑。

3.5 对象存储 (MinIO) 与多媒体管理

应用会产生大量用户生成的图片和视频文件，不适合直接存储于MySQL。因此采用MinIO对象存储来保存这些非结构化数据。MinIO是开源的高性能对象存储服务，兼容S3接口，支持海量图片、视频等文件的分布式存储。部署MinIO可以作为私有云存储方案，提供安全可扩展的文件存储。

存储内容：包括：

用户上传的头像、封面图等小型资源。

AI生成的漫画分镜图和最终合成视频文件。每条作品发布时，将对应视频上传MinIO保存。若作品是图片形式，也将图片打包或逐张保存。

其他静态资源：如应用的插画素材、预置的背景音乐文件等（也可存MinIO或随应用打包）。

Bucket设计：可按资源类型建立不同Bucket，如 avatars（用户头像），covers（封面图），content-images，content-videos 等。也可按用户/作品分类存储。例如为每个用户单独一个bucket（不太必要）。更简单方式是以目录结构区分：如 content/{contentId}/image1.png, content/{contentId}/video.mp4 等路径，这样放在同一个Bucket里也清晰。

访问方式：用户端访问媒体文件通常有两种方案：

经过后端中转：客户端请求内容时，后端生成一个受限URL或通过后端API返回文件流。这种方式便于权限控制（如防止未授权访问内容），但增加后端带宽压力。

直连URL：为公开内容提供直接的MinIO对象URL或CDN加速URL。MinIO可设置预签名URL（带有效期的签名），后端生成签名后客户端直接用URL访问对象。这样降低服务器负载，并可结合CDN对热门内容进行缓存加速。

本产品初期内容免费公开，考虑使用直连方式提升效率：后台在Content表的media_url直接存储可访问的HTTP链接。MinIO部署在服务器并绑定域名，比如https://media.mysite.com, 则文件URL为该域名+路径。对敏感文件（如未审核内容），后台不下发URL或使用短时效签名URL防泄漏。

MinIO集成：后端通过MinIO Java SDK与存储交互。上传文件时，后端获取文件流（用户上传的或AI生成的）调用 MinioClient.putObject() 将文件存入指定Bucket。SDK提供丰富接口如检查Bucket存在、列出对象等。MinIO也有Web管理界面，方便开发运维查看文件。

备份与容量：为防止数据丢失，MinIO可部署为分布式集群模式，利用纠删码技术保证某节点故障不丢数据。在部署建议部分会详述。需要制定定期备份策略，将关键Bucket的数据周期性快照备份到异地（或利用云厂商OSS备份）。

3.6 缓存与性能优化 (Redis)

采用 Redis 内存数据库提升系统性能和可扩展性。Redis作为高性能键值存储，常用于缓存热点数据、实现高并发下的快速响应。在本架构中Redis的应用包括：

Session缓存：如果不使用JWT无状态方案，而采用传统会话登录，Redis可用来保存用户会话信息（token->用户数据）。这样应用服务器可无状态处理，每次验证从Redis获取用户信息，支持水平扩展。即便JWT方案，仍可利用Redis存放黑名单token、用户登录态等需要即时失效的数据。

热点数据缓存：将经常读取的不频繁变化的数据缓存在Redis。例如热门作品列表、首页推荐列表、某作品的点赞数、评论数等。读取时先查缓存，缓存命中则直接返回，未命中再查数据库并回填缓存。这样减少数据库压力，提高响应速度。缓存采用合理的过期策略，确保数据最终一致性，如作品数据缓存设30秒过期或者在更新操作后主动清除相关缓存。

排名计数：利用Redis的有序集合(zset)实现排行榜，例如根据点赞数实时排序的Top N作品。发布或点赞时同时更新Redis中的排行数据，这比每次数据库排序高效。Redis支持上百万QPS的操作，非常适合高频统计场景。

分布式锁：某些业务需要锁来保证一致性，如防止用户重复触发并发生成任务，可使用Redis实现分布式锁。比如锁key为"user:{id}:gen_lock"，在任务进行时加锁，防止二次请求；任务完成后释放锁。Redis的原子性保证让锁可靠简单。

消息队列：Redis的List或Stream可以用作简易消息队列，在任务调度中使用。如一个“生成任务队列”list，后端将任务ID push进队列，AI工作线程从队列pop任务执行。这种生产者-消费者模型利用Redis的操作实现异步处理，解耦请求提交和实际执行。当然，也可用更专业的消息中间件如RabbitMQ/Kafka等，但Redis轻量快速即可满足初期需求。

Redis部署在服务器内存中，读写极快，但要注意持久化配置（RDB或AOF）防止数据丢失，以及内存淘汰策略避免超出内存。缓存数据一般可以容忍丢失，重要的是session等需要持久化。合理规划内存和数据ttl时间，保证缓存命中率的同时不占用过多资源。

3.7 AI推理服务与任务流程

AI 漫剧生成涉及调用多种AI模型（剧本生成、图像生成、配音等）。考虑到模型运行的复杂性和资源消耗，我们设计AI推理部分与主业务服务解耦，形成独立的AI推理服务模块。其技术方案和流程如下：

AI推理服务架构：可以使用Python开发一个微服务，集成所需AI模型（例如HuggingFace的Transformer模型用于文本生成，大型扩散模型用于图像生成，甚至视频生成模型等）。该服务对外提供API或通过消息队列接收任务，由后台异步调用。由于AI模型可能需要GPU加速，将AI服务部署在具备GPU的机器上，通过REST或RPC与主后端通信。初期也可直接在后端Java中调用云端AI API（如调用OpenAI API获取文本，调用第三方AI绘画API获取图像），以减少自研成本。

生成流程分解：根据漫剧生成的步骤，AI服务可按流水线执行：

剧本生成：调用大语言模型（如ChatGPT或本地类似GPT的模型）输入prompt，生成剧情脚本文本。输出包含分段场景描述和对白。可选模型包括OpenAI GPT-4、百度文心一言等，视API可用性选择。也可以微调针对剧情的模型提升质量。

分镜拆分：解析剧本文本，将剧本划分为多个场景卡。AI服务可以在剧本文本中插入特殊标记表示分镜点，或者由后端逻辑根据句子/段落拆分。对每个场景生成一段简短描述（要绘制的内容说明）。

图像生成：针对每个场景描述，调用扩散模型生成相应图片。使用开源Stable Diffusion并fine-tune成动漫风格模型，或者调用专门的漫画生成模型（如Anything V5模型等）。需要解决角色一致性问题：可采用两种办法，一是对主要角色使用面部识别+文本反推技术，把第一张图中角色形象标识出来，然后在后续prompt中加入该角色特征描述强化一致性；二是使用LoRA微调或角色embedding，提前训练特定角色风格后生成。KomikoAI等专业工具就是通过结构化阶段流程确保故事驱动的一致输出。我们的AI服务也可以引入类似Agent逻辑，保证生成的连贯性。

配音 & 视频：文本转语音TTS可以使用云服务（如科大讯飞、Azure TTS等）为对白生成音频，再与图像合成视频。如果暂不做配音，则只选配乐。AI服务完成图像后，可直接调用ffmpeg库将图像序列+字幕+背景音乐合成为MP4视频文件。也可进一步添加简单的运动特效，如对某些部分放大缩小以增加动感。漫剧本质是动态漫画，通过技术手段赋予静态图像以镜头感。

输出：AI服务将最终生成的视频文件保存（可以直接上传MinIO或返回给主后端由后端上传），以及中间生成的剧本文本、分镜图。如果有需要，也将这些返回，供主后端存数据库。

任务调度：当后端收到生成请求时（/api/generate），会在本地记录任务并立即响应任务ID给客户端，然后通过以下两种方式触发AI处理：

方案A: 主动请求 – 后端使用HTTP调用AI服务的接口，如POST /ai/generateTask，附上任务ID和prompt等。AI服务接收后在后台处理，处理完成后调用后端的回调接口通知结果或让后端去取。

方案B: 消息队列 – 后端将任务消息写入Redis队列或Kafka主题。AI服务订阅队列获取任务，处理完后把结果放入结果队列或直接写数据库标记完成。

方案B解耦更好，而且当AI服务挂掉时任务消息还在，不会丢失。出于实现便捷，可先使用Redis List，主后端RPUSH任务ID到列表，AI服务持续BRPOP等待任务。

任务状态更新：在任务进行过程中，后端可以提供查询接口返回 status 和 progress。AI服务可以定期将进度写回（如多少%或当前阶段），更新在数据库 generate_tasks 表中。客户端查询时由后端读表返回。如果使用WebSocket，也可在关键阶段推送消息如“剧本生成完成”、“图像生成50%”等，提高用户感知。大多数情况下短视频生成几分钟内可完成，所以简单轮询也能接受。

错误处理：若AI生成失败，如prompt不当或模型服务异常，AI服务应捕获异常并返回错误状态码。后端拿到后设置任务状态为失败，error_msg填入错误信息。客户端查询到失败可提示用户调整prompt重试。为了改进模型，可将失败的prompt记录日志供后续分析改进。

扩展计划：初期大量依赖云端算力。随着模型优化和移动端硬件发展，可探索端侧部署一部分功能。例如将一个轻量化的文本生成模型或图像超分模型集成在App，让客户端离线完成某些步骤。但鉴于目前扩散模型对硬件要求高，短期仍以云端推理为主。架构上将AI服务模块抽象，未来可切换到本地推理或边缘计算服务器，而不影响主应用架构。

值得注意的是，AI生成带来的版权与安全问题需要技术上规避。指出行业面临同质化和侵权风险，我们应保证模型使用合法数据训练，生成内容也提示用户遵守版权。同时平台禁止用户将AI生成内容冒充原创发布以获利 – 我们社区目前不涉商业，仍需倡导尊重原创和版权的社区规范。

3.8 技术选型理由与部署方案

最后总结关键技术栈的选型原因，并提出部署和运维建议：

Android (Kotlin + Compose)：Kotlin 成熟稳健且兼具现代特性，已成为Android官方主推语言。Jetpack Compose简化了UI开发，提升开发效率和UI一致性。二者搭配使我们的小团队也能快速迭代出高质量App界面。同时Compose支持Material设计和自定义主题，非常适合塑造个性化二次元风格UI。

Java 后端 (Spring MVC, MyBatis)：Java生态在企业级开发中验证多年，Spring框架提供丰富的功能、良好的安全支持和庞大社区。SSM架构清晰分层利于分工开发。相比更现代的Spring Boot/Microservices，选择传统SSM是因为团队可能对此更熟悉，而且在初期单体架构阶段已足够使用。MyBatis可以直接编写SQL，方便针对复杂查询优化。Java的强类型和JVM性能也能保证服务器稳定性和可扩展性。

MySQL 数据库：MySQL作为关系数据库非常可靠，能保证数据的一致性和安全存储。它拥有完善的ACID事务支持和丰富的运维工具，足以支撑从小规模到千万级用户的业务。同时MySQL社区活跃，我们可以方便地查阅资料、获得支持。后续如果业务增长巨大，也可平滑迁移到分布式数据库或云数据库服务。

Redis 缓存：Redis以其内存存储和高吞吐，被广泛用于Web系统缓存、计数器、队列等场景，能够显著提升系统响应速度。对于本产品这种读多写少的社区应用，缓存热点数据可以应对高并发访问，同时利用Redis实现分布式锁和异步队列简化了架构。Redis的使用将大幅减轻数据库压力，让系统具有更高的伸缩性。

MinIO 对象存储：引入MinIO是考虑到多媒体文件管理的需要。相比直接使用本地文件系统，MinIO提供了类似AWS S3的标准接口和分布式存储能力。它易于横向扩展容量，并支持数据冗余和校验保障文件安全。对于海量图片视频的场景，这是可靠的选择。此外，使用对象存储还能方便地对接CDN，加速内容分发，提高用户观看体验。

AI大模型服务：AI生成是产品卖点，但自己训练模型成本高。因此我们采取集成已有的大模型API（OpenAI, 文心大模型等）或开源模型部署。短期内依赖云端服务可以快速上线功能，随着技术积累和成本考虑，再逐步替换为自有模型部署甚至端侧推理。云端AI的好处是持续更新最先进模型，比如2025年字节跳动推出的Seedance2.0生成模型可显著提升漫剧制作效率和质量。我们应保持开放性，灵活接入新的AI能力。

部署建议：

应用服务器：初期可在一台云服务器部署整体后端（Java应用+MySQL+Redis+MinIO all-in-one for testing）。但是生产环境建议分离各组件：如使用一台专门的DB服务器（或云托管MySQL实例），一台Redis服务器（内存优化机型），一台存储服务器部署MinIO服务（并接入云厂商对象存储做镜像备份）。Java应用部署在独立的应用服务器上，运行在Tomcat或Spring内置容器中。由于SSM是单体架构，可容纳于一个部署包。确保开启安全组策略，只开放必要端口（443/80给客户端，3306给应用等）。

AI服务：若使用自建AI服务，需要GPU支持。可租用云GPU服务器，部署AI推理服务（Python Flask/FastAPI等）和模型权重。初期负载低时也可与应用服务器共存（CPU跑小模型），但为了生成效率，GPU服务更佳。AI服务也可以弹性伸缩，比如高峰期多开实例处理任务。

CDN与域名：申请域名用于服务API和媒体，加配SSL证书确保HTTPS通信安全。将静态内容（MinIO对象）绑定到CDN，减少网络延迟和带宽压力。中国境内部署需注意合规和CDN/存储的备案。

容器化：建议使用 Docker 容器封装各服务，方便部署和环境一致。可以一个容器跑Java应用，一个容器跑AI服务，一个跑MinIO等。未来当用户量提升，可以考虑使用 Kubernetes 来编排容器，实现微服务扩展和弹性伸缩。例如将不同模块（用户服务、内容服务、AI服务）拆分部署各自的pod，实现真正的微服务架构。但在MVP阶段，容器化主要为部署便利，并不急于拆分。

持续集成：建立CI/CD流程，代码提交后自动构建测试，确保主干稳定。采用灰度发布策略，先在测试环境验证再上线生产。利用日志系统（ELK）和监控告警（Prometheus+Grafana）及时发现性能瓶颈或异常。

通过上述架构设计，我们将能够开发出功能全面的AI漫剧创作社区App。该方案结合了成熟社区产品的模块划分和AI内容生产的新兴技术，以Android原生应用为载体，Java后端为支撑，集成AI云能力，构建起一个面向二次元内容爱好者的创新平台。在实现易用创作的同时，也确保系统具有良好的性能和扩展性，为未来可能的用户增长和功能扩展打下基础。我们相信，随着不断优化，这款应用将有效降低漫剧创作门槛，让每个人都能做出自己的动漫短剧，并在社区中找到归属感，共同推动二次元内容创作的繁荣发展
